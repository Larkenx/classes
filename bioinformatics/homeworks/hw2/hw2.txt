Homework 2
Name: Steven Myers
User: stelmyer

1) If we are given the following motifs (AAA, CAT, GAC, ATA), we would have a consensus string of
AAA since A appears most frequently in all columns of the given motifs. Now, let's find the median string of the motifs, trying each
given motif as our median...
  AAA has a minimum of 1.
  CAT has a minimum of 2.
  GAC has a minimum of 2.
  ATA has a minimum of 1.
So, our consensus string AAA is also a median string (even though we have two median strings here). With k-mers of
larger length, we will find that there will be fewer cases in which there are more than one median string. It is also not likely one of
our motifs will indeed be our consensus.

2) Since obtaining the consensus of motifs guarantees the maximum occurences of each nucleotide in each column, it only follows that
the consensus will contain the minimum number of differences (the median string) out of all other motifs. We've shown this in problem #1.
However, Dr. Smart does not address the case in which our motifs are > length 15.

In situations where we have a very large k length and large 1000-nucleotide long strings, we will obtain degenerative motifs which may not be the median strings.

3) Mr Fuzzy's algorithm is as follows...

Input: Dna (Set of DNA Sequences), integer k
FuzzyMedianString(Dna, k)
for each string Text in Dna { // For each DNA strand in DNA set
  d_min <- k × t; // Maximum possible mismatches is the length of k-mers times the number of cases
  for each k-mer P in Text { // Get each k-mer substring from the strand
    d <- 0
    for each string Text’ in Dna such that Text’ ≠ Text { // Get every other strand that isn't the current strand
      d_min’ <- k // Has a max of k mismatches
      for each k-mer P’ in Text’ { // For all kmers in all other DNA strands
        d’ <- HammingDistance(P, P’) // Record the distance between every other kmer across DNA strands
        if d’ < d_min’ {
          d_min’ <- d’ // Put the smallest distance in the current min
        }
      }
    }
  }

   d <- d + d_min’
   if d < d_min {
    d_min <- d
    median <- P
  }
}
Output median

The algorithm is correct! I documented what each step of the algorithm does. The algorithm
properly compares every kmer in every strand Text in the set of DNA strands, against every other kmer prime.
It properly records the minimum distance over all the kmers, and returns the k-mer P
which corresponds to the median string

4) For the Gibbs sampling to use both stands of the DNA (reverse complement) -
we can just feed the motifs into .... /* FIX ME */
